---
title: "spMOCA for gene co-expression analysis in spatial transcritomics studies"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{spMOCA for gene co-expression analysis in spatial transcritomics studies}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette shows an example of applying `spMOCA` to estimate gene-gene correlations between their expression patterns, extract co-expressed gene modules and perform gene set analysis for the modules to annotate their functions.

# 0. Install Package

```{r, include = FALSE}
#### install packages
install.packages("~/ParallelCode/spMOCA_1.0.tar.gz", repos = NULL, type="source")
```

# 1. Load packages and data

```{r setup, warning = FALSE, message = FALSE}
library(spMOCA)
library(Seurat)
library(SPARK)
library(WGCNA)
library(msigdbr)
```

In this vignette, we use the 10x Visium Ovarian Carcinoma data download from [10x Genomics Data Platform](https://www.10xgenomics.com/datasets/human-ovarian-cancer-1-standard). The preprocessed raw count matrix and spatial coordinate data are stored in XXXX.


```{r eval = FALSE}
#### Loading data
count_data = readRDS("~/data/Project/spMOCA/Visium_Tumor/1.PreprocessedData/OVCA.10xGenomicsFFPE.count.mat.rds") # count matrix
location = readRDS("~/data/Project/spMOCA/Visium_Tumor/1.PreprocessedData/OVCA.10xGenomicsFFPE.location.rds") # location matrix

#### Check whether the orders of location dimension are matched in two matrix
all(location$barcode == colnames(count_data))

#### re-format location dataframe
location = as.data.frame(location)
rownames(location) = location$barcode
location = location[,c("pxl_row_in_fullres","pxl_col_in_fullres")]
colnames(location) = c("x","y")
all_gene = rownames(count_data)
```

# 2. Create SpMOCA Object, Normalization and Feature Selection

Here we create a spMOCA object for the following calculation. After that we performed a log transformation with a library size factor normalization. We performed a feature section by detecting spatial variable genes (SVGs) using SPARK [Sun et al.](https://www.nature.com/articles/s41592-019-0701-7). Usually it will take a while for running SPARK. To save time for this tutorial, we provide the already-run SPARK output for OVCA data.

```{r eval = FALSE}
##### Create spMOCA object
object = createSPMOCAObject(spatial_countMat = count_data,
                            spatial_location = location,
                            feature_list = all_gene)

#### Normalization
object = normalizeSPMOCA(object)

#### Feature Selection
spark.res = readRDS(paste0("~/data/Project/spMOCA/Visium_Tumor/3.IntermediateOutput/OVCA.10xGenomicsFFPE.spark.res.rds"))
sign.res = as.data.frame(spark.res@res_mtest) %>%
  dplyr::filter(adjusted_pvalue <= 0.05)
gene_spark = rownames(sign.res)

object = featureSelectionSPMOCA(object,
                                feature.selection = NULL,
                                feature.list = gene_spark)

```

# 3. Construct Spatial Kernel and Run `spMOCA` to estimate gene-gene correlation

```{r eval = FALSE}
#### Construct Spatial Kernel
object = createSpatialKernel(object)

#### Estimate Gene-Gene Correlation
object = estimatespMOCA(object)
```

# 3. Downstream analysis on gene co-expression network  

## 3.1 Extract gene module from gene-gene correlation matrix

We apply [WGCNA](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-9-559) to extract gene modules. In particular, we use `spMOCA` estimated gene-gene correlation  as an input to perform clustering for genes through WGCNA.


```{r eval = FALSE}
#### Perform Module Detection
object = moduleDetectionspMOCA(object)
```
## 3.2 Calculate Network Degree and Module Scores

We next can calculate global connectivity and within-module connectivity for each gene given the module labels we obtained from WGCNA. We can further calculate module scores using top 5% hub genes as representatives. 

```{r eval = FALSE}
ms_prop = calModuleScore(object)
### Visualize Module Score
ms = scale(ms_prop[,1])
ms[which(is.na(ms),arr.ind = T)] = 0

df.ms = cbind(location,ms)
colnames(df.ms) = c("x","y","score")

ggplot(df.ms,aes(x = x,y = y,color = score)) +
  geom_point(size = 3) +
  labs(color = "Module Score",
       title = paste0("OVCA Module1")) +
  scale_color_gradientn(colours = c("#006D77","#83C5BE","#EDF6F9","#FFDDD2","#E29578")) +
  theme(plot.margin = margin(0.1, 0.1, 0.1, 0.1, "cm"),
        panel.background = element_blank(),
        plot.background = element_blank(),
        plot.title = element_text(size = 30),
        panel.border = element_rect(colour = "grey89", fill=NA, size=0.5),
        axis.text =element_blank(),
        axis.ticks =element_blank(),
        axis.title =element_blank(),
        legend.title=element_text(size = 20,face="bold"),
        legend.text=element_text(size = 20),
        legend.key = element_rect(colour = "transparent", fill = "white"),
        legend.key.size = unit(0.45, 'cm'),
        strip.text = element_text(size = 16,face="bold"),
        legend.position="bottom")
```


## 3.3 Gene Set Analysis

We can further perform a gene set analysis following the instructions in the Method and Material in our [manuscript](link). Specifically, we construct a two-way contingency table by categorizing genes based on their presence in the gene module as hub genes and the corresponding gene set, to measure the odds for genes in the pathways appearing in the gene module.

```{r eval=FALSE}
##### Extracted Human Gene Sets from GSEA
m_df_tumor <- msigdbr(species = "Homo sapiens")
fgsea_sets <- m_df_tumor %>% 
  split(x = .$gene_symbol, f = .$gs_name)

all_gs = unique(m_df_tumor[,c("gs_cat","gs_subcat","gs_name")])
target_gs = all_gs$gs_name[all_gs$gs_cat == "C5"]

fgsea_sets = fgsea_sets[target_gs]
fgsea_sets = fgsea_sets[1:100] # First 100 Ontology Gene Sets
##### Focusing On Gene Ontology 
##### Calculate Odd Ratios
gene_cluster = hubgene.module.all
gene_num_modular = length(unique(hubgene.module.all$k))


binary_gene_set = list()
count_gene_set = list()

odds_gene_set = matrix(0,nrow = gene_num_modular,ncol = length(fgsea_sets))
pval_gene_set = matrix(0,nrow = gene_num_modular,ncol = length(fgsea_sets))

module = gtools::mixedsort(unique(gene.module.all$k))
colnames(odds_gene_set) =
  colnames(pval_gene_set) = names(fgsea_sets)
rownames(odds_gene_set) = rownames(odds_gene_set) = module

bg_gene = gene_spark # background gene 
for(k in 1:gene_num_modular){
  print(k)
  member = gene_cluster$gene[gene_cluster$k == module[k]]
  Geneset = matrix(0,nrow = length(member),ncol = length(fgsea_sets))
  rownames(Geneset) = member
  colnames(Geneset) = names(fgsea_sets)
  
  
  for(ig in 1:length(fgsea_sets)){
    if(sum(member %in% fgsea_sets[[ig]]) > 0){
      # entry of binary matrix
      Geneset[member %in% fgsea_sets[[ig]],ig] = 1
      # entry of odds ratio matrix
      binary_all_gene_in_module = ifelse(bg_gene %in% member,1,0) # in-module-indicators of selected genes 
      binary_all_gene_in_set = ifelse(bg_gene %in% fgsea_sets[[ig]],1,0) # in-gene-set-indicators of selected genes
      cont.table = table(binary_all_gene_in_module,binary_all_gene_in_set)
      cont.table = cont.table[c(2,1),c(2,1)]
      odds_gene_set[k,ig] = as.numeric(fisher.test(cont.table)$estimate)
      pval_gene_set[k,ig] = as.numeric(fisher.test(cont.table)$p.value)
    }
  }
  binary_gene_set[[module[k]]] = Geneset
}

# exclude gene set
count_in_set = matrix(0,nrow = gene_num_modular,ncol = length(fgsea_sets))
for(k in 1:gene_num_modular){
  count_in_set[k,] = colSums(binary_gene_set[[k]])
}
exclude_by_count = which(colSums(count_in_set) == 0) # gene sets have no gene in all modules
exclude_by_odds = which(is.infinite(colSums(odds_gene_set))) # gene sets have infinite odd ratios
exclude_col = union(exclude_by_count,exclude_by_odds) 

odds_gene_set[which(odds_gene_set ==0,arr.ind = T)] =  NA
pval_gene_set[which(pval_gene_set ==0,arr.ind = T)] =  NA
```




