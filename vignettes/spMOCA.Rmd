---
title: "spMOCA for gene co-expression analysis in spatial transcritomics studies"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{spMOCA for gene co-expression analysis in spatial transcritomics studies}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette shows an example of applying `spMOCA` to estimate gene-gene correlations between their expression patterns, extract co-expressed gene modules and perform gene set analysis for the modules to annotate their functions.

# 1. Load packages and data

```{r setup, warning = FALSE, message = FALSE}
library(spMOCA)
library(Seurat)
library(SPARK)
library(WGCNA)
library(msigdbr)
```

In this vignette, we use the 10x Visium Ovarian Carcinoma data download from [10x Genomics Data Platform](https://www.10xgenomics.com/datasets/human-ovarian-cancer-1-standard). The preprocessed raw count matrix and spatial coordinate data are stored in XXXX.


```{r eval = FALSE}
#### Loading data
count_data = readRDS("~/data/Project/spMOCA/Visium_Tumor/1.PreprocessedData/OVCA.10xGenomicsFFPE.count.mat.rds") # count matrix
location = readRDS("~/data/Project/spMOCA/Visium_Tumor/1.PreprocessedData/OVCA.10xGenomicsFFPE.location.rds") # location matrix

#### Check whether the orders of location dimension are matched in two matrix
all(location$barcode == colnames(count_data))
```

# 2. Normalization and Feature Selection

Here we performed a log transformation with a library size factor normalization. We performed a feature section by detecting spatial variable genes (SVGs) using SPARK [Sun et al.](https://www.nature.com/articles/s41592-019-0701-7). 

```{r eval = FALSE}
##### Normalization 
normCount = sweep(count_data,2,colSums(count_data),"/")
normCount = log1p(normCount * 10000)
normCount = as.matrix(normCount)

##### SVGs Feature Selection using SPARK
location_coord = as.data.frame(location[,3:4])
location_coord[,1] = as.numeric(location_coord[,1])
location_coord[,2] = as.numeric(location_coord[,2])
rownames(location_coord) = location$barcode
spark <- CreateSPARKObject(counts=count_data,
                           location=location_coord,
                           percentage = 0.1,
                           min_total_counts = 5)
spark@lib_size <- apply(spark@counts, 2, sum)
spark <- spark.vc(spark,
                  covariates = NULL,
                  lib_size = spark@lib_size,
                  num_core = parallel::detectCores(),
                  verbose = F)
spark <- spark.test(spark,
                    check_positive = T,
                    verbose = F)
```

# 3. Construct Spatial Kernel and Run `spMOCA` to estimate gene-gene correlation

```{r eval = FALSE}
##### Subset the normalized expression matrix to SVGs
spark.res = readRDS(paste0("~/data/Project/spMOCA/Visium_Tumor/3.IntermediateOutput/OVCA.10xGenomicsFFPE.spark.res.rds"))
sign.res = spark.res@res_mtest %>%
  filter(adjusted_pvalue <= 0.05)
gene_spark = rownames(sign.res)
normCount = normCount[rownames(normCount) %in% gene_spark,]

##### Create Spatial Gaussian Kernel V 
spatial_coord = location[,c(5,6)]
colnames(spatial_coord) = c("x","y")
rownames(spatial_coord) = location$barcode

V = createSpatialKernel(spatialCoord = spatial_coord,
                        normCount = normCount)

##### Estimate Gene-Gene Correlation R 
REst = spMOCAest(normCount = normCount,
                spatialKernel = V)
rownames(REst) = colnames(REst) = gene_spark
```

# 3. Downstream analysis on gene co-expression network  

## 3.1 Extract gene module from gene-gene correlation matrix

We apply [WGCNA](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-9-559) to extract gene modules. In particular, we use `spMOCA` estimated gene-gene correlation  as an input to perform clustering for genes through WGCNA.


```{r eval = FALSE}
# Rounding correlation matrix to make it runable for WGCNA
corr.mat = round(REst,6)
corr.mat[lower.tri(corr.mat)] = t(corr.mat)[lower.tri(corr.mat)]

# Compute the adjacency matrix based on the co-expression matrix
adj.mat = WGCNA::adjacency.fromSimilarity(corr.mat, power = 1,type = "signed")
# Compute the topological overlap matrix
TOM = WGCNA::TOMsimilarity(adj.mat)
dissTOM = 1-TOM
rownames(dissTOM) <- colnames(dissTOM) <- rownames(corr.mat)
hclust_dist = hclust(as.dist(dissTOM)) 
wcgna_label = dynamicTreeCut::cutreeDynamic(dendro = hclust_dist,
                                            distM = dissTOM,
                                            deepSplit = T,
                                            pamRespectsDendro = FALSE,
                                            minClusterSize = 400)


```
## 3.2 Calculate Network Degree and Module Scores

We next can calculate global connectivity and within-module connectivity for each gene given the module labels we obtained from WGCNA. We can further calculate module scores using top 5% hub genes as representatives. 

```{r eval = FALSE}
##### Calculate Gene's Global and Within-Module Connectivity
gene.module.all = intramodularConnectivity( (corr.mat + 1)/2,
                                            colors = wcgna_label)
gene.module.all$k = wcgna_label
gene.module.all$gene = rownames(corr.mat)


##### Calculate Module Score 
hubgene.module.all = gene.module.all %>%
  group_by(k) %>%
  top_frac(0.05,kWithin)
num_cluster_wcgna = length(unique(wcgna_label)[which(unique(wcgna_label) != 0)])

ms_prop = NULL
for(kk in 1:num_cluster_wcgna){
  module_net = hubgene.module.all[hubgene.module.all$k == kk,]
  genesModule = module_net$gene
  sub_count = normCount[genesModule,]
  ms_prop = cbind(ms_prop,colMeans(sub_count))
}

### Visualize Module Score
ms = scale(ms_prop[,1])
ms[which(is.na(ms),arr.ind = T)] = 0

df.ms = cbind(location[,c("pxl_row_in_fullres","pxl_col_in_fullres")],ms)
colnames(df.ms) = c("x","y","score")

ggplot(df.ms,aes(x = x,y = y,color = score)) +
  geom_point(size = 3) +
  labs(color = "Module Score",
       title = paste0("OVCA Module1")) +
  scale_color_gradientn(colours = c("#006D77","#83C5BE","#EDF6F9","#FFDDD2","#E29578")) +
  theme(plot.margin = margin(0.1, 0.1, 0.1, 0.1, "cm"),
        panel.background = element_blank(),
        plot.background = element_blank(),
        plot.title = element_text(size = 30),
        panel.border = element_rect(colour = "grey89", fill=NA, size=0.5),
        axis.text =element_blank(),
        axis.ticks =element_blank(),
        axis.title =element_blank(),
        legend.title=element_text(size = 20,face="bold"),
        legend.text=element_text(size = 20),
        legend.key = element_rect(colour = "transparent", fill = "white"),
        legend.key.size = unit(0.45, 'cm'),
        strip.text = element_text(size = 16,face="bold"),
        legend.position="bottom")
```


## 3.3 Gene Set Analysis

We can further perform a gene set analysis following the instructions in the Method and Material in our [manuscript](link). Specifically, we construct a two-way contingency table by categorizing genes based on their presence in the gene module as hub genes and the corresponding gene set, to measure the odds for genes in the pathways appearing in the gene module.

```{r eval=FALSE}
##### Extracted Human Gene Sets from GSEA
m_df_tumor <- msigdbr(species = "Homo sapiens")
fgsea_sets <- m_df_tumor %>% 
  split(x = .$gene_symbol, f = .$gs_name)

all_gs = unique(m_df_tumor[,c("gs_cat","gs_subcat","gs_name")])
target_gs = all_gs$gs_name[all_gs$gs_cat == "C5"]

fgsea_sets = fgsea_sets[target_gs]
fgsea_sets = fgsea_sets[1:100] # First 100 Ontology Gene Sets
##### Focusing On Gene Ontology 
##### Calculate Odd Ratios
gene_cluster = hubgene.module.all
gene_num_modular = length(unique(hubgene.module.all$k))


binary_gene_set = list()
count_gene_set = list()

odds_gene_set = matrix(0,nrow = gene_num_modular,ncol = length(fgsea_sets))
pval_gene_set = matrix(0,nrow = gene_num_modular,ncol = length(fgsea_sets))

module = gtools::mixedsort(unique(gene.module.all$k))
colnames(odds_gene_set) =
  colnames(pval_gene_set) = names(fgsea_sets)
rownames(odds_gene_set) = rownames(odds_gene_set) = module

bg_gene = gene_spark # background gene 
for(k in 1:gene_num_modular){
  print(k)
  member = gene_cluster$gene[gene_cluster$k == module[k]]
  Geneset = matrix(0,nrow = length(member),ncol = length(fgsea_sets))
  rownames(Geneset) = member
  colnames(Geneset) = names(fgsea_sets)
  
  
  for(ig in 1:length(fgsea_sets)){
    if(sum(member %in% fgsea_sets[[ig]]) > 0){
      # entry of binary matrix
      Geneset[member %in% fgsea_sets[[ig]],ig] = 1
      # entry of odds ratio matrix
      binary_all_gene_in_module = ifelse(bg_gene %in% member,1,0) # in-module-indicators of selected genes 
      binary_all_gene_in_set = ifelse(bg_gene %in% fgsea_sets[[ig]],1,0) # in-gene-set-indicators of selected genes
      cont.table = table(binary_all_gene_in_module,binary_all_gene_in_set)
      cont.table = cont.table[c(2,1),c(2,1)]
      odds_gene_set[k,ig] = as.numeric(fisher.test(cont.table)$estimate)
      pval_gene_set[k,ig] = as.numeric(fisher.test(cont.table)$p.value)
    }
  }
  binary_gene_set[[module[k]]] = Geneset
}

# exclude gene set
count_in_set = matrix(0,nrow = gene_num_modular,ncol = length(fgsea_sets))
for(k in 1:gene_num_modular){
  count_in_set[k,] = colSums(binary_gene_set[[k]])
}
exclude_by_count = which(colSums(count_in_set) == 0) # gene sets have no gene in all modules
exclude_by_odds = which(is.infinite(colSums(odds_gene_set))) # gene sets have infinite odd ratios
exclude_col = union(exclude_by_count,exclude_by_odds) 

odds_gene_set[which(odds_gene_set ==0,arr.ind = T)] =  NA
pval_gene_set[which(pval_gene_set ==0,arr.ind = T)] =  NA
```




